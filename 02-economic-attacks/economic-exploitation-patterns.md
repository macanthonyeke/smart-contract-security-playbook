# Economic Exploitation Patterns

## 1. Title
Economic Exploitation Patterns

## 2. Overview
Economic exploits manipulate protocol assumptions about price, liquidity, governance power, and execution ordering to produce profitable but protocol-damaging outcomes.

## 3. Core Mental Model
**Definition:** An economic exploit exists when an attacker can construct a strategy with positive expected value (EV) under realistic worst-case execution assumptions.

Profitability framework:
\[
\Pi = \text{ExtractedValue} - \text{SlippageCost} - \text{Fees} - \text{BorrowCost} - \text{OpportunityCost}
\]
Security goal: enforce controls so max attacker \(\Pi \le 0\) under stress assumptions.

### Why This Matters in DeFi/Real Protocols
Code can be bug-free yet economically insecure. Protocol insolvency often starts from manipulable oracle/liquidity/governance assumptions.

## 4. Minimal Vulnerable Example (Solidity or pseudocode)
```solidity
function borrow(uint256 collateralAmount) external {
    uint256 p = ammSpotOracle.price(collateral); // manipulable same-block
    uint256 limit = collateralAmount * p * LTV / 1e18;
    debt[msg.sender] += limit;
    stable.mint(msg.sender, limit);
}
```

## 5. Realistic Exploit Scenario (step-by-step transaction flow)
Flash-loan oracle manipulation:
1. `Tx1`: attacker flash-borrows base asset.
2. `Tx1`: attacker pushes AMM spot price up on thin pair.
3. `Tx1`: protocol reads manipulated spot and mints oversized borrow.
4. `Tx1`: attacker unwinds trade, repays flash loan, keeps surplus borrow value.

Liquidity illusion:
1. Attacker adds temporary concentrated liquidity to satisfy health checks.
2. Executes borrow/mint path relying on instantaneous depth.
3. Removes liquidity immediately; liquidation path later faces no depth.

Reflexive liquidation cascade:
1. Initial price drop triggers liquidations.
2. Liquidators dump collateral into shallow books.
3. Additional price impact triggers further liquidations and bad debt.

Flash-loan governance case study:
- Beanstalk (2022): attacker borrowed large governance weight in one transaction, passed malicious proposal, and executed treasury drain with flash-loan-funded voting power.

MEV amplification dynamics:
- Searchers sandwich liquidations/rebalances, worsening execution prices and accelerating system stress.

## 6. Defensive Design Patterns
- TWAP + multi-source oracles with deviation/staleness checks.
- Liquidity-adjusted limits based on executable depth, not TVL headline.
- Governance snapshots with seasoning/holding windows and execution delays.
- Circuit breakers for abnormal oracle divergence and volatility.
- Auction mechanisms designed to reduce cascade feedback loops.
- MEV-aware execution (batch auctions, commit-reveal, protected relays).

MEV amplification vs traditional arbitrage:
- **Arbitrage** restores pricing efficiency and is usually inventory-risk constrained.
- **MEV amplification** exploits ordering power around user/protocol flows, often increasing user slippage and protocol loss without restoring fair value quickly.

## 7. EVM-Level Reasoning
- Atomic composability lets attackers borrow, manipulate, exploit, and unwind in one transaction.
- Mempool visibility enables deterministic front-run/back-run construction.
- Same-block state reads are economically adversarial when tied to manipulable AMM states.

## 8. Common Developer Mistakes
- Using single-venue spot prices for collateral valuation.
- Ignoring borrowed voting power in governance security model.
- Assuming minimum liquidity is stable across transaction boundaries.
- Designing risk limits without stress market-impact modeling.

## 9. Explicit, Strong Invariants
```solidity
function invariant_oracleManipulationBound() public {
    assertLe(maxBorrowFromSingleBlockPriceMove(), configuredBorrowImpactCap());
}

function invariant_governanceCannotBorrowAndExecuteSameWindow() public {
    assertFalse(canGainVotingPowerAndExecuteWithinBorrowWindow());
}

function invariant_worstCaseEVNonPositive() public {
    assertLe(simulatedWorstCaseAttackerProfit(), 0);
}
```

### How Tests Should Catch This
- Fork/integration tests should simulate flash-loan capital and same-block oracle shocks.
- Governance tests should attempt borrow-vote-execute in one window and require revert/failure.
- Monte Carlo or scenario tests should compute attacker EV with slippage/fee models and fail when EV turns positive.
